# v0.5.0 친구/차단/초대 백엔드 설계

## 1. 목적과 범위
- 친구 관계(요청/수락/거절)와 차단, 게임 초대 흐름을 백엔드 도메인으로 구현한다.
- v0.5.0 범위에서는 NORMAL 매치 초대를 지원하며, 차단 관계일 경우 모든 소셜 액션을 차단한다.
- WebSocket을 활용해 친구 요청/수락/초대 이벤트를 푸시할 수 있는 최소 브로드캐스터 구조를 추가한다.

## 2. 배경과 요구사항 정리
- PRODUCT_SPEC.md의 Social & Friends 항목과 VERSIONING.md v0.5.0 범위를 따른다.
- 차단 시 친구 요청/초대가 모두 거부되어야 하며, 동일 쌍에서 중복 요청이 생성되지 않아야 한다.
- 초대 수락 시 즉시 GameRoom을 생성해 roomId를 반환해야 한다.

## 3. 아키텍처 개요
- 패키지: `com.codexpong.backend.social`
  - `domain`: FriendRequest, Friendship, Block, GameInvite, 상태 Enum 정의
  - `repository`: 각 엔티티에 대한 Spring Data JPA 리포지토리
  - `service`: SocialService(도메인 로직), SocialEventPublisher(WebSocket 브로드캐스터)
  - `controller`: SocialController(REST API)
  - `SocialWebSocketHandler`: `/ws/social` 엔드포인트에서 인증된 세션을 등록
- 기존 `WebSocketConfig`에 소셜 핸들러 등록, 인증 인터셉터 재사용

## 4. 데이터 모델
- FriendRequest(id, sender, receiver, status(PENDING/ACCEPTED/REJECTED), createdAt, respondedAt)
- Friendship(id, userA, userB, createdAt)
  - userA/userB는 id 크기 기준으로 정렬해 중복을 방지하는 Unique 제약
- Block(id, blocker, blocked, createdAt)
  - Unique(blocker, blocked)
- GameInvite(id, sender, receiver, status(PENDING/ACCEPTED/REJECTED), matchType, roomId, createdAt, respondedAt)
- Hibernate `ddl-auto=update`를 활용해 H2/MariaDB 스키마 자동 생성

## 5. API 설계
- Base: `/api/social` (모든 엔드포인트 인증 필요)
- 친구
  - `GET /friends`: FriendSummaryResponse 목록(online, since 포함)
  - `GET /friend-requests`: incoming/outgoing 요청 묶음 응답
  - `POST /friend-requests {targetUsername}`: 친구 요청 생성 (상대가 보낸 PENDING 존재 시 자동 수락)
  - `POST /friend-requests/{id}/accept|reject`: 요청 처리
- 차단
  - `GET /blocks`: 차단 목록 조회
  - `POST /blocks {targetUsername}`: 차단 추가(기존 친구 관계 삭제, 보류 요청 제거)
  - `DELETE /blocks/{userId}`: 차단 해제
- 초대
  - `POST /invites {targetUserId}`: NORMAL 매치 초대 생성(친구가 아니면 403)
  - `GET /invites/incoming|outgoing`: 대기 중 초대 조회
  - `POST /invites/{id}/accept|reject`: 초대 처리, accept 시 GameRoom 생성 및 roomId 반환
- 예외 처리: 차단 관계/중복 요청/이미 처리된 요청은 400~403 에러 메시지를 한국어로 반환

## 6. WebSocket 이벤트
- 엔드포인트: `/ws/social` (JWT 쿼리 파라미터 또는 Authorization 헤더 필요)
- SocialEventPublisher가 사용자별 세션을 추적하여 online 여부 판단 및 다음 이벤트를 전송:
  - `FRIEND_REQUEST`: 친구 요청 수신
  - `FRIEND_ACCEPTED` / `FRIEND_REJECTED`: 친구 요청 처리
  - `GAME_INVITE`: 초대 수신
  - `INVITE_ACCEPTED` / `INVITE_REJECTED`: 초대 처리 결과
- 메시지 형식: `{ "type": "EVENT", "payload": { ...dto... } }` JSON 문자열

## 7. 서비스 로직 요약
- SocialService
  - `requestFriend`: 차단 여부/이미 친구 여부 검사 → 상대가 보낸 PENDING 존재 시 즉시 accept → 새 요청 생성
  - `acceptRequest/rejectRequest`: 상태 확인 후 업데이트, 친구 수락 시 Friendship 생성
  - `block`: 친구/요청/초대 정리 후 Block 저장
  - `sendInvite`: 친구 여부, 차단 여부 확인 후 GameInvite 생성
  - `acceptInvite`: GameRoomService.createRoom 호출 후 invite 상태 업데이트
  - 모든 처리 후 관련 사용자에게 SocialEventPublisher.publish로 알림 전송

## 8. 테스트 전략
- `SocialFlowTest` 통합 테스트에서 회원가입 → 친구 요청/수락 → 차단/해제 → 초대 수락까지 HTTP 흐름 검증
- 기존 테스트 프로파일(H2, JWT 시크릿) 재사용
- WebSocket 핸들러는 인증된 세션 등록 여부만 확인하도록 단위 수준 최소화(통합 테스트는 REST 중심)

## 9. 배포/마이그레이션 고려사항
- 새 테이블 생성(FriendRequest, Friendship, Block, GameInvite)을 위해 초기 마이그레이션 시 DB 권한 확인
- /ws/social 경로가 프록시(Nginx)에서 노출되어야 함(CLONE_GUIDE에 반영)
- 향후 DM/채팅과 통합 시 Block 관계를 재사용하고 이벤트 타입 확장 가능하도록 Publisher 구조 유지
