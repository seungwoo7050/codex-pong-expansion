# v0.12.0 워커/큐 토폴로지 설계

## 1. 목적
- 리플레이 내보내기 잡을 메인 백엔드와 분리된 **replay-worker** 프로세스에서 처리해 안정성을 높인다.
- Redis Streams 기반 큐 토폴로지를 정의해 요청/진행률/결과를 신뢰성 있게 전달한다.
- Docker Compose 수준에서 필요한 환경변수, 볼륨, 네트워크 구성을 고정한다.

## 2. 범위
- Redis Streams 선택(단일 큐 메커니즘)과 스트림 키 명세.
- `replay-worker` 서비스 구성(Dockerfile, ffmpeg CLI 포함).
- 백엔드/워커가 공유하는 스토리지/네트워크/환경변수.
- 최소 재시도 및 데드레터 정책.

## 3. 토폴로지
### 3.1 스트림/컨슈머 그룹
- 요청 스트림: `job.requests`
  - 프로듀서: 백엔드 `JobQueuePublisher`.
  - 컨슈머: `replay-worker`(단일 워커 혹은 여러 워커가 동일 그룹으로 묶여 각 메시지를 1회 소비).
- 진행률 스트림: `job.progress`
  - 프로듀서: 워커.
  - 컨슈머: 백엔드 `JobQueueListener` → `JobService`.
- 결과 스트림: `job.results`
  - 프로듀서: 워커.
  - 컨슈머: 백엔드 `JobQueueListener`.
- 컨슈머 그룹: `replay-jobs`를 모든 스트림에서 사용해 추적/ACK 일관성을 맞춘다.
- 데드레터 스트림: `job.deadletter`(백엔드가 처리 실패 레코드를 이동). 운영자가 필요 시 재발행한다.

### 3.2 메시지 스키마 (고정)
- 요청: `{ jobId, jobType, replayId, options }` (`options`에 `inputPath`, `outputPath`, `durationMs`, `ownerId`, `createdAt`).
- 진행률: `{ jobId, progress, phase, message }`.
- 결과: `{ jobId, status, resultUri, checksum, errorCode, errorMessage }`.

## 4. 서비스 구성
### 4.1 Docker Compose
- `redis`: `redis:7-alpine`, `appendonly no`, 포트 `6379` 노출.
- `backend`: `REDIS_HOST`, `JOB_QUEUE_*`, `JOB_EXPORT_PATH` 환경변수 설정, `/data/replays` 볼륨 마운트.
- `replay-worker`:
  - `worker/Dockerfile` 기반 Python 이미지에 **ffmpeg CLI** 설치.
  - 환경변수: `REDIS_HOST`, `JOB_QUEUE_REQUEST_STREAM`, `JOB_QUEUE_PROGRESS_STREAM`, `JOB_QUEUE_RESULT_STREAM`, `JOB_QUEUE_CONSUMER_GROUP`, `WORKER_ID`, `JOB_EXPORT_PATH`.
  - 볼륨: `/data/replays`(백엔드와 공유)로 결과 파일을 동일 경로에 저장.
  - 재시작 정책: `unless-stopped`로 백엔드와 격리.

### 4.2 네트워크/스토리지
- 모든 서비스가 Docker 기본 브리지 네트워크를 공유, 스트림 키는 네임스페이스 없이 단일 Redis 인스턴스를 사용.
- 리플레이/내보내기 산출물은 `replay_data` 볼륨(`/data/replays`)에 저장해 백엔드 `resultUri`와 워커 출력 경로가 일치하도록 한다.

## 5. 워커 동작
- `worker/main.py`가 `job.requests`를 블록킹 소비 → JSONL 리플레이를 파싱 → Pillow로 코트/패들/공/점수를 렌더링 → raw RGB 프레임을 ffmpeg stdin으로 전달한다.
  - MP4: `ffmpeg -y -f rawvideo -pix_fmt rgb24 -s 1280x720 -r 20 -i pipe:0 -c:v libx264 -pix_fmt yuv420p -movflags +faststart`.
  - 썸네일: 동일 렌더러로 중간 프레임 1장을 PNG로 저장.
- `-progress pipe:1`에서 out_time_ms(마이크로초)를 파싱해 예상 ms 대비 비율을 0~99%로 계산 후 `progress/phase/message`를 발행한다.
- 출력 경로는 `jobs.export.path` 하위인지 검증하며, 벗어나면 `INVALID_OUTPUT_PATH`로 실패 처리한다.
- 성공 시 `resultUri`와 SHA-256 체크섬을 포함한 결과 메시지를 전송, 실패 시 `errorCode/errorMessage`를 채운다.
- 워커 장애 시 컨슈머 그룹에 남은 pending 메시지는 재시작 직후 `XAUTOCLAIM`으로 회수 후 처리해 정체를 방지한다.
- 임시 프레임 파일을 생성하지 않는 스트리밍 파이프라인을 기본으로 하며, ffmpeg 실패/예외가 발생하면 `.tmp` 임시 파일까지 삭제한 후 정상 파일명으로 원자적 rename을 수행한다.
- GitHub Actions CI에서는 ffmpeg/ffprobe를 사전 설치하고, `REQUIRE_FFMPEG=1` 환경으로 워커 단위 테스트를 실행해 실제 MP4/PNG 생성과 ffprobe 검증까지 강제한다.

## 6. 재시도/멱등성 정책
- 백엔드: 동일 jobId 중복 생성 방지, 터미널 상태 이후 이벤트 무시, 처리 실패 레코드는 `job.deadletter`로 이동 후 ACK.
- 워커: 동일 jobId 메시지를 재처리하더라도 `outputPath` 기준으로 덮어쓰기 없이 성공/실패를 단일 레코드로 발행해야 한다.
- 운영 재시도: deadletter를 검사해 필요 시 동일 메시지를 `job.requests`로 다시 발행(멱등성 유지).

## 7. 운영 메모
- Redis/ffmpeg 사용량 모니터링을 위해 Prometheus에 큐 길이/워커 처리 시간 메트릭을 추후 추가할 수 있도록 여지를 둔다.
- 로컬 실행 시 ffmpeg가 설치되어 있어야 하며, `JOB_QUEUE_ENABLED=false`로 백엔드를 구동하면 잡 큐 소비를 비활성화할 수 있다(테스트용).
