# v1.4.0 플랫폼화(K8s + IaC + GitOps)

## 목표
- kind/minikube 기반으로 재현 가능한 쿠버네티스 배포 경로를 제공한다.
- Terraform으로 네임스페이스/ArgoCD 베이스라인을 선언해 IaC 흐름을 확정한다.
- ArgoCD Application을 통해 GitOps 동기화 경로를 정의한다.
- backend(gateway 역할 포함)에 대한 readiness/liveness + 그레이스풀 셧다운을 보장해 롤링 업데이트 중 접속 정책을 보호한다.

## 구성 요소
- 네임스페이스: `codexpong`
- 워크로드(K8s base):
  - `backend` Deployment(2 replicas): `/actuator/health/{readiness,liveness}` 프로브 + `preStop` 슬립 10초 + `terminationGracePeriodSeconds=40`
  - `frontend` Deployment: NodePort로 호스트 노출(포트 30073)
  - `replay-worker` Deployment: Redis 큐 소비, `pgrep` 기반 생존 검사, `/data/replays` 존재 여부로 readiness 확인
  - `mariadb`/`redis` StatefulSet + PVC
  - 재생 데이터 PVC: `replay-data`(5Gi)
- 오버레이:
  - `infra/k8s/overlays/kind`: backend(30080)/frontend(30073) NodePort로 로컬 접근을 단순화
  - `infra/k8s/overlays/gitops`: GitOps 대상 기본 오버레이(ClusterIP 유지)
- IaC: `infra/terraform`
  - `kubernetes_namespace.codexpong`
  - `helm_release.argocd`(chart `argo-cd`, namespace `argocd`)
- GitOps: `infra/gitops/argocd-application.yaml`(repo=이 저장소, path=`infra/k8s/overlays/gitops`, automated sync+prune)

## 로컬 배포(k kind 예시)
1. 준비물: `kind`, `kubectl`, `kustomize`(kubectl 내장 가능), Docker daemon
2. 이미지 빌드/적재
   ```bash
   docker build -t codexpong/backend:local backend
   docker build -t codexpong/frontend:local frontend
   docker build -t codexpong/replay-worker:local worker
   kind create cluster --name codexpong --image kindest/node:v1.30.0
   kind load docker-image codexpong/backend:local codexpong/frontend:local codexpong/replay-worker:local --name codexpong
   ```
3. 매니페스트 적용
   ```bash
   kubectl apply -k infra/k8s/overlays/kind
   kubectl get pods -n codexpong
   ```
4. 접속 경로(NodePort)
   - 백엔드 API/WS: `http://localhost:30080/api/health`, `ws://localhost:30080/ws/...`
   - 프런트엔드: `http://localhost:30073`
5. 롤링 업데이트 확인 예시
   ```bash
   kubectl -n codexpong rollout restart deploy/backend
   kubectl -n codexpong rollout status deploy/backend
   ```
   - readiness 프로브(10초 delay) + preStop 10초 + graceful shutdown(30초 이상)으로 연결 끊김을 최소화한다.

## Terraform 베이스라인
- 위치: `infra/terraform`
- 주요 변수: `kubeconfig_path`(기본 `~/.kube/config`), `cluster_namespace`(기본 `codexpong`), `argocd_chart_version`
- 실행 예시(로컬 상태, 원격 백엔드 없이):
  ```bash
  cd infra/terraform
  terraform init -backend=false
  terraform plan \
    -var "kubeconfig_path=${HOME}/.kube/config" \
    -var "cluster_namespace=codexpong"
  ```
- 적용 시 ArgoCD가 `argocd` 네임스페이스에 설치되고, 이후 GitOps Application으로 워크로드를 동기화한다.

## GitOps 플로우
1. Terraform으로 ArgoCD 설치(또는 Helm 직접 설치).
2. GitOps 애플리케이션 등록:
   ```bash
   kubectl apply -f infra/gitops/argocd-application.yaml
   ```
3. ArgoCD UI/CLI에서 `codexpong-platform`을 sync → `infra/k8s/overlays/gitops` 기준으로 배포.
4. 변경 관리: PR 머지 → ArgoCD가 자동 self-heal/prune로 상태 일치.

## 테스트/검증
- 정적 검증: `./scripts/test-infra.sh` (PyYAML/HCL 파싱으로 프로브/NodePort/IaC/GitOps 설정 확인)
- 백엔드 헬스/셧다운 테스트: `./scripts/test-backend.sh` → `/actuator/health` 공개 여부와 graceful 설정을 JUnit으로 검증.
- 통합 테스트(전체): `./scripts/test-all.sh`

## 운용 메모
- readiness/liveness 엔드포인트: `/actuator/health/readiness`, `/actuator/health/liveness` (무인증 공개).
- 그레이스풀 셧다운: Spring Boot `server.shutdown=graceful`, `spring.lifecycle.timeout-per-shutdown-phase=30s` + Pod `preStop: sleep 10`으로 롤링 중 in-flight 처리 여유 확보.
- MariaDB/Redis는 상태 저장을 위해 StatefulSet+PVC를 사용하며, 개발 편의용 기본 비밀번호를 사용한다(실배포 시 Secret으로 교체 필요).
