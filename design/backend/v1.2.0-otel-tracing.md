# v1.2.0 백엔드 OTEL/메트릭 설계

## 1. 목표
- API→게이트웨이→샤드→워커까지 traceId를 잃지 않고 전달한다.
- 필수 메트릭 4종을 Micrometer/OTel 기반으로 노출한다.

## 2. 구성 요소
- **TelemetryConfig**: OTLP gRPC 익스포터(환경변수 `OTEL_EXPORTER_OTLP_ENDPOINT`), W3C TraceContext 프로퍼게이터, HTTP p95 MeterFilter를 Bean으로 제공.
- **TraceContextFilter**: `X-Trace-Id` 응답 헤더를 노출하며, W3C `traceparent`를 추출해 서버 스팬을 시작.
- **ObservabilityMetrics**: `realtime.ws.connections`, `realtime.match.start`, `realtime.tick.jitter` 관리.
- **TraceSupport**: 수신한 traceId로 원격 부모 컨텍스트를 생성하고 스팬을 생성.

## 3. 흐름별 트레이싱
1) **REST API**: `TraceContextFilter` → `RequestLoggingFilter` → 컨트롤러. `X-Trace-Id` 값은 게이트웨이/샤드에 그대로 전달 가능.
2) **게이트웨이** (`GatewaySessionManager`): traceId 정규화 후 `gateway.*` 스팬 생성, 성공/실패 카운터(`realtime.ws.connections`). 메시지 envelope에 traceId 포함.
3) **샤드** (`GameSessionShard`): 메시지 traceId로 `shard.*` CONSUMER 스팬 생성, `realtime.match.start`/`realtime.tick.jitter` 기록.
4) **워커** (`worker/main.py`): OTLP/Console 익스포터. Redis 요청 필드의 `traceId`를 인식해 `worker.process.*`, `worker.export_*` 스팬 생성.

## 4. 메트릭 정의
- `realtime.ws.connections{status}`: 게이트웨이 오픈/재접속 성공/실패 카운터.
- `realtime.match.start{status}`: 샤드에서 START_GAME 처리 성공/실패 카운터.
- `realtime.tick.jitter`: tick 호출 간격과 설정된 heartbeat 간격의 절대 편차(ms) Summary, p95 노출.
- `http.server.requests`: MeterFilter로 p95 계산, Prometheus 스크랩 가능.

## 5. 추적 상관관계 규칙
- traceId 입력이 W3C 규격이 아니면 새 traceId를 생성하되 `correlation.trace_id` 속성에 원본 값을 남긴다.
- 클라이언트는 `X-Trace-Id`를 그대로 WS 연결 쿼리/헤더에 전달하면 게이트웨이/샤드 스팬이 동일 traceId로 묶인다.
- 워커 잡 요청 필드에 `traceId` 키를 포함하면 결과 스팬이 같은 trace로 묶인다.

## 6. 테스트 포인트
- `TraceCorrelationIntegrationTest`: API 스팬에서 시작된 traceId가 게이트웨이/샤드 스팬과 동일한지 검증, jitter 메트릭 수집 확인.
- 워커 단위 테스트는 기존 `test_exporter.py`를 유지하며, 스팬 생성은 Console/OTLP 환경에서 수동 확인.
