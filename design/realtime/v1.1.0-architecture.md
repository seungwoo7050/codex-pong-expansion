# v1.1.0 실시간 아키텍처 요약

## 목적/범위
- WebSocket 모놀리식 핸들링을 분리해 `realtime-gateway`(stateless)와 `game-session-shard`(권위 세션)로 수평 확장한다.
- Redis를 단일 상태/라우팅/메시징 계층으로 사용하며 결정적 종료 정책(B)을 강제한다.

## 컴포넌트
- **realtime-gateway**: 인증 토큰 검증, 세션→샤드 라우팅, Streams를 통한 메시지 릴레이. 상태 없음.
- **game-session-shard**: 권위 게임 루프, 세션 상태 관리, termination context 기록.
- **Redis**: shard registry(hash), heartbeat 키(expire), session→shard 매핑(hash), termination context(hash), Streams(`game:request:{shardId}`, `game:response:{sessionId}`).

## 데이터 흐름
1. 클라이언트가 `/ws/game?sessionId&token`으로 연결 → 게이트웨이에서 토큰 검증 후 shard 선택.
2. `SESSION_CONNECTED` 메시지가 `game:request:{shardId}`에 기록되고 shard가 `SESSION_ACK` 응답.
3. 게임 진행 중 입력은 `FORWARD_INPUT`으로 스트림에 추가, 샤드는 상태를 계산 후 `STATE_SNAPSHOT` 이벤트를 응답 스트림으로 발행.
4. 종료 시 `TERMINATED{reason}`를 기록하고 termination context를 `termination:{sessionId}`에 보관.

## 하트비트/선택 정책
- shard는 `heartbeat:{shardId}` 키를 주기적으로 갱신한다(TTL=5s 기본).
- 게이트웨이는 활성 shard 집합에서 라운드로빈으로 선택(단일 구현은 첫 번째). 하트비트 만료 시 세션은 `SHARD_UNAVAILABLE`로 종료.

## 장애/결정적 종료
- 토큰 검증 실패 → `AUTH_FAILURE` 컨텍스트 기록 후 즉시 종료.
- shard heartbeat 소실 또는 매핑 불가 → `SHARD_UNAVAILABLE` 기록 후 종료.
- 게임 종료 → `NORMAL_COMPLETION` 컨텍스트.
- 악용 정책 트립 → `POLICY_TERMINATED`.

## 테스트 전략
- 결정적 시간 주입(DeterministicClock)으로 루프/하트비트 검증.
- 게이트웨이-샤드 핸드셰이크, 재접속, shard kill 시나리오를 단위 테스트로 고정.
- Streams idempotency는 `messageId` 기반으로 샤드 측에서 보장(추후 구현 시 리더/팔로워 모두 동일 로직 적용).

## 마이그레이션/호환성
- v1.0 WebSocket 엔드포인트는 내부적으로 게이트웨이로 프록시되며 메시지 envelope는 `contracts/ws.v1.1.0.md` 스펙을 따른다.
- 단일 노드 배포에서도 Redis 기반 흐름을 유지해 재배포/스케일링 시 상태 이동이 필요 없다.
