# v0.14.0 리플로우/레이아웃 성능 리포트

## 1. 개요
- 대상 화면: `/leaderboard`, `/jobs` (요구사항에 따라 2개 명시).
- 목표: 긴 리스트에서 레이아웃 thrashing을 제거하고 페이징/가상화를 적용한 뒤 before/after 트레이스를 확보한다.

## 2. 측정 환경
- 프런트엔드 개발 서버: Vite dev, 포트 8000.
- 데이터: Playwright 스크립트로 API 응답 목킹(120명 리더보드, 80개 잡). 인증 토큰은 localStorage에 고정.
- 도구: `page.tracing.start/stop`(Chromium) 기반 DevTools Performance 캡처.

## 3. 캡처 파일
- 저장소에는 바이너리 ZIP을 포함하지 않는다. 필요 시 아래 스크립트로 로컬 `reports/performance/v0.14.0/` 경로에 생성해 DevTools로 확인한다.
- 생성 스크립트: `frontend/scripts/captureReflowTrace.js` (Playwright). 네트워크 차단으로 로컬 Chromium 설치가 실패할 경우, `browser_container.run_playwright_script`로 동일 패턴을 실행할 수 있다.

## 4. 관찰 결과
- 리더보드: 페이징 적용 후 Layout/Recalculate Style 구간이 짧아지고, 스크롤 중 자주 발생하던 스타일/레이아웃 교차 호출이 제거됨.
- 작업 목록: 80개 항목을 단일 렌더 시 발생하던 긴 레이아웃 블록이 사라지고, 페이지 전환 시에만 제한된 페인트가 발생.
- 공통: 라이브 매치 맵/소켓 상태를 메모이제이션 및 제한된 재시도 정책으로 묶어 렌더링 반복 시 메모리/CPU 스파이크가 줄어듦.

## 5. 재현 절차
1) `npm install` (프런트), `npm run dev -- --host --port 8000 --strictPort` 실행.
2) 별 터미널에서 `node frontend/scripts/captureReflowTrace.js` 실행. (Chromium 설치가 막힐 경우, 브라우저 컨테이너로 동일 스크립트 실행)
3) 생성된 `reports/performance/v0.14.0/*.zip`(로컬 생성물) 을 Chrome DevTools의 Performance 탭에서 열어 Layout/Rendering 구간을 비교한다.
